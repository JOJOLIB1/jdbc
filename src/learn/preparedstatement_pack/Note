对于迭代器的Iterator
0. 默认指针在索引-1的位置
1. hasNext()方法主要判断是否还有元素可以被迭代
2. Next()方法主要是让指针下一并返回元素

对于结果集ResultSet
0. 默认指针在索引-1的位置
1. Next()方法兼顾以上两种方法的功能,即如果还有元素可以迭代,返回true并指针下移,否则返回false指针不再下移

ORM思想(Object Rational Mapping):
    一个数据表对应一个Java类
    一条记录对应一个Java类的实例
    一个字段对应这一个实例的属性

    SQL索引从1开始,Java索引从0开始
    修饰数据的数据被称为元数据

    SQL中返回的DATE类型是sql包下的Date类型,不是util包下的

    1.当MySQL数据库中的字段名和Java类中的属性名不一致的时候,我们可以通过别名过度
    2.getColumnName获取列的列名
        2.1 getColumnLabel获取列的别名,如果没有起别名,则默认列名就充当别名(使用这个)

占位符一般写在不确定的过滤条件中,表和字段不要写占位符
占位符可以解决SQL注入问题

PrepareStatement的好处
    1.解决了SQL注入问题
        1.当我们调用PrepareStatement的时候,将带占位符的SQL语句传参,进行了对SQL语句的预编译,此刻,MySQL知道了SQL语句的执行
        逻辑,当我们填充占位符的时候会根据之前所知道的执行逻辑去执行
        2.倘若没有预编译这个步骤,即没有填充占位符这个操作,先将过滤条件填入,过滤条件可能会引起与本意相违背的SQL逻辑,而此刻MySQL并没编译,
        所以会编译改变原意后的SQL语句,造成了SQL注入问题
    2.更高效的批量操作
        1.我们可以通过不断的覆盖填充占位符即可批量操作
        2.否则我们需要些大量的SQL语句
    3.可以操作Blob的数据
        1.可以通过流给占位符赋值,就可以操作Blob数据
        2.Statement没有占位符,不可能在SQL语句上写一个文件

面向接口编程的真谛:
    在编写代码中完全不会出现第三方API




execute()
    若返回ture,则说明有结果集,否则没有结果集
1.executeUpdate() 2.executeQuery()
    1.返回值为int类型,即影响了N行数据

结果集中的getObject()等方法有重载
    1.参数是Label,填字段的别名,这个更灵活
    2.参数是index,填索引